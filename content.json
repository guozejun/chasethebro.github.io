{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"C# 属性（Property）","text":"C#在字段的基础上延伸出了属性的概念。属性定义包含get和set两个成员用于检索该属性的值以及对其赋值。可以在属性声明的大括号之后通过等号对其进行初始化，适用于不想将属性赋值为系统默认值时的情况。 123456public class Person{ public string FirstName { get; set; } = string.Empty; // remaining implementation removed from listing} 属性可以作为class structure interface的命名成员，","link":"/2020/12/14/C-%E5%B1%9E%E6%80%A7/"},{"title":"C# 特性（Attribute）","text":"特性分为预定义特性和自定义特性，用于在运行时传递各种元素的行为信息的声明性标签。 12[attribute(positional_parameters, name_parameter = value, ...)]element","link":"/2020/12/15/C-%E7%89%B9%E6%80%A7/"},{"title":"C# 类型","text":"值类型12345678910111213141516171819202122232425262728293031323334353637using System;public struct MutablePoint{ public int X; public int Y; public MutablePoint(int x, int y) =&gt; (X, Y) = (x, y); public override string ToString() =&gt; $&quot;({X}, {Y})&quot;;}public class Program{ public static void Main() { var p1 = new MutablePoint(1, 2); var p2 = p1; p2.Y = 200; Console.WriteLine($&quot;{nameof(p1)} after {nameof(p2)} is modified: {p1}&quot;); Console.WriteLine($&quot;{nameof(p2)}: {p2}&quot;); MutateAndDisplay(p2); Console.WriteLine($&quot;{nameof(p2)} after passing to a method: {p2}&quot;); } private static void MutateAndDisplay(MutablePoint p) { p.X = 100; Console.WriteLine($&quot;Point mutated in a method: {p}&quot;); }}// Expected output:// p1 after p2 is modified: (1, 2)// p2: (1, 200)// Point mutated in a method: (100, 200)// p2 after passing to a method: (1, 200) 如上述代码所示，对值类型的修改只会作用到变量本身，对给他赋值的右值变量没有影响。 整型数值类型整形数值类型支持算数、位逻辑、比较和相等运算符，可以用文本进行初始化。包含有以下类型 C# 类型 大小 .NET 类型 sbyte 8bit System.SByte byte 8bit(u) System.Byte short 16bit System.Int16 ushort 16bit(u) System.Uint16 int 32bit System.Int32 uint 32bit(u) System.UInt32 long 64bit System.Int64 ulong 64bit(u) System.UInt64 C# 类型关键字可以和.NET类型互换，前者是后者的别名，每个整形都会被系统初始化为0.每个整形都有MinValue和MaxValue常量，提供该类型的最大值和最小值。System.Numerics.BigInteger用于表示没有上限或下限的带符号整数。 12int a = 123;System.Int32 b = 123; 整数文本 十进制：没有前缀 十六进制：0x 0X前缀 二进制：0b 0B前缀 123var decimalLiteral = 42;var hexLiteral = 0x2A;var binaryLiteral = 0b_0010_1010; _可以作为数字分隔符用于所有类型的数字文本。整数文本的类型由其后缀决定： 如果没有后缀，从下列类型中选取第一个可以表示其类型的类型：int uint long ulong 如果文本以U u结尾，uint ulong 文本以L l结尾，long ulong 如果整数字面量超过了UInt64.MaxValue出现编译器错误。 浮点数值类型浮点数值类型支持算数、位逻辑、比较和相等运算符，可以用文本进行初始化。 C# 类型 精度 大小 .NET 类型 float 6-9 4byte System.Single double 15-17 8byte System.Double decimal 28-29 16byte System.Decimal 浮点类型关键字可以和.NET类型互换，默认初始化值为0。浮点类型有MinValue和MaxValue常量。float和double提供非数字和无穷大的常量，NaN NegativeInfinity PositiveInfinity。与 float 和 double 相比，decimal 类型具有更高的精度和更小的范围，因此它适合于财务和货币计算。 可在表达式中将整形类型与 float 和 double 类型混合使用。 在这种情况下，整型类型隐式转换为其中一种浮点类型，float 类型可能隐式转换为 double。 此表达式的计算方式如下： 如果表达式中有 double 类型，则表达式在关系比较和相等比较中求值得到 double 或 bool。 如果表达式中没有 double 类型，则表达式在关系比较和相等比较中求值得到 float 或 bool。 你还可在表达式中混合使用整型类型和 decimal 类型。 在这种情况下，整型类型隐式转换为 decimal 类型，并且表达式在关系比较和相等比较中求值得到 decimal 或 bool。 不能在表达式中将 decimal 类型与 float 和 double 类型混合使用。 在这种情况下，如果你想要执行算术运算、比较运算或相等运算，则必须将操作数显式转换为 decimal 或反向转换，如下例所示： 1234double a = 1.0;decimal b = 2.1m;Console.WriteLine(a + (double)b);Console.WriteLine((decimal)a + b); 实数文本实数文本的类型由后缀决定： 不带后缀的文本或带有 d 或 D 后缀的文本的类型为 double 带有 f 或 F 后缀的文本的类型为 float 带有 m 或 M 后缀的文本的类型为 decimal 还可以使用科学计数法表示： 12345678double d = 0.42e2;Console.WriteLine(d); // output 42float f = 134.45E-2f;Console.WriteLine(f); // output: 1.3445decimal m = 1.5E6m;Console.WriteLine(m); // output: 1500000 浮点数值类型之间只有一种隐式转换：从 float 到 double。 但是，可以使用显式强制转换将任何浮点类型转换为任何其他浮点类型。 内置数值转换隐式类型转换 From To sbyte short、int、long、float、double 或 decimal byte short、ushort、int、uint、long、ulong、float、double 或 decimal short int、long、float、double 或 decimal ushort int、uint、long、ulong、float、double 或 decimal。 int long、float、double 或 decimal uint long、ulong、float、double 或 decimal long float、double 或 decimal ulong float、double 或 decimal float double 任何整型数值类型都可以隐式转换为任何浮点数值类型。 不存在针对 byte 和 sbyte 类型的隐式转换。 不存在从 double 和 decimal 类型的隐式转换。 decimal 类型和 float 或 double 类型之间不存在隐式转换。 类型 int 的常量表达式的值（例如，由整数文本所表示的值）如果在目标类型的范围内，则可隐式转换为 sbyte、byte、short、ushort、uint 或 ulong。 显式类型转换 From To sbyte byte、ushort、uint 或 ulong byte sbyte short sbyte、byte、ushort、uint 或 ulong ushort sbyte、byte 或 short int sbyte、byte、short、ushort、uint 或 ulong uint sbyte、byte、short、ushort 或 int long sbyte、byte、short、ushort、int、uint 或 ulong。 ulong sbyte、byte、short、ushort、int、uint 或 long。 float sbyte、byte、short、ushort、int、uint、long、ulong 或 decimal double sbyte、byte、short、ushort、int、uint、long、ulong、float 或 decimal decimal sbyte、byte、short、ushort、int、uint、long、ulong、float 或 double 整形之间的转换取决于 checking context。如果在checked context中，值不越界才能转换成功，否则就会抛出OverflowException。如果在unchecked context，转换总是会成功，执行结果如下： 如果源类型大于目标类型，会舍弃最高有效位。 如果源类型小于目标类型，会被sign-extended或者zero-extended，有符号数被sign-extended，无符号数被zero-extended。 如果大小相同会被直接转换 如果decimal类型转换为整形，首先会去掉小数部分，如果结果比目标类型的范围大，抛出OverflowException。 如果float和double类型向整形转换，那么在去掉小数部分之后，需要查看checking context，看情况是否抛出OverflowException。 将 double 转换为 float，doube值会被舍入为最接近的float值，如果double值太大或者太小，结果是0或者无穷大。 float或者double转换为decimal的时候，源值转换为 decimal 表示形式，并并五入到第 28 位小数后最接近的数（如果需要）。 根据源值的值，可能出现以下结果之一： 如果源值太小，无法表示为 decimal，结果则为零。 如果源值为 NaN（非数值）、无穷大或太大而无法表示为 decimal，则引发 OverflowException。 charchar 类型关键字是 .NET System.Char 结构类型的别名，它表示 Unicode UTF-16 字符。 类型 范围 大小 .NET 类型 char U+0000 到 U+FFFF 16 位 System.Char char 类型的默认值为 \\0，即 U+0000。 char 类型支持比较、相等、增量和减量运算符。 此外，对于 char 操作数，算数和逻辑位运算符对相应的字符代码执行操作，并得出 int 类型的结果。 字符串类型将文本表示为 char 值的序列。 文本可以使用以下命令指定 char 值： 字符文本。 Unicode 转义序列，它是 \\u 后跟字符代码的十六进制表示形式（四个符号）。 十六进制转义序列，它是 \\x 后跟字符代码的十六进制表示形式。 12345678var chars = new[]{ 'j', '\\u006A', '\\x006A', (char)106,};Console.WriteLine(string.Join(&quot; &quot;, chars)); // output: j j j j 对于 Unicode 转义序列，必须指定全部四位十六进制值。 也就是说，\\u006A 是一个有效的转义序列，而 \\u06A 和 \\u6A 是无效的。 对于十六进制转义序列，可以省略前导零。 也就是说，\\x006A、\\x06A 和 \\x6A 转义序列是有效的，并且对应于同一个字符。 转换char 类型可隐式转换为以下整型类型：ushort、int、uint、long 和 ulong。 它也可以隐式转换为内置浮点数值类型：float、double 和 decimal。 它可以显式转换为 sbyte、byte 和 short 整型类型。 无法将其他类型隐式转换为 char 类型。 但是，任何整型或浮点数值类型都可显式转换为 char。 枚举类型枚举类型 是由基础整型数值类型的一组命名常量定义的值类型。 若要定义枚举类型，使用 enum 关键字并指定枚举成员 的名称： 1234567enum Season{ Spring, Summer, Autumn, Winter} 默认情况下，枚举成员的关联常数值为类型 int；它们从零开始，并按定义文本顺序递增 1。 可以显式指定任何其他整数数值类型作为枚举类型的基础类型。 还可以显式指定关联的常数值，如下面的示例所示： 1234567enum ErrorCode : ushort{ None = 0, Unknown = 1, ConnectionLost = 100, OutlierReading = 200} 结构类型结构类型（“structure type”或“struct type”）是一种可封装数据和相关功能的值类型 。 使用 struct 关键字定义结构类型： 12345678910111213public struct Coords{ public Coords(double x, double y) { X = x; Y = y; } public double X { get; } public double Y { get; } public override string ToString() =&gt; $&quot;({X}, {Y})&quot;;} readonly结构从 C# 7.2 开始，可以使用 readonly 修饰符来声明结构类型不可变： 12345678910111213public readonly struct Coords{ public Coords(double x, double y) { X = x; Y = y; } public double X { get; init; } public double Y { get; init; } public override string ToString() =&gt; $&quot;({X}, {Y})&quot;;} readonly实例成员从 C#8.0 开始，还可以使用 readonly 修饰符声明实例成员不会修改结构的状态。 如果不能将整个结构类型声明为 readonly，可使用 readonly 修饰符标记不会修改结构状态的实例成员。 在 readonly 实例成员内，不能分配到结构的实例字段。 但是，readonly 成员可以调用非 readonly 成员。 在这种情况下，编译器将创建结构实例的副本，并调用该副本上的非 readonly 成员。 因此，不会修改原始结构实例。 通常，将 readonly 修饰符应用于以下类型的实例成员： 方法： 1234public readonly double Sum(){ return X + Y;} 属性和索引器 123456private int counter;public int Counter{ readonly get =&gt; counter; set =&gt; counter = value;} 元组类型元组功能在 C# 7.0 及更高版本中可用，它提供了简洁的语法，用于将多个数据元素分组成一个轻型数据结构。 下面的示例演示了如何声明元组变量、对它进行初始化并访问其数据成员： 123456789(double, int) t1 = (4.5, 3);Console.WriteLine($&quot;Tuple with elements {t1.Item1} and {t1.Item2}.&quot;);// Output:// Tuple with elements 4.5 and 3.(double Sum, int Count) t2 = (4.5, 3);Console.WriteLine($&quot;Sum of {t2.Count} elements is {t2.Sum}.&quot;);// Output:// Sum of 3 elements is 4.5. 元组赋值与析构C# 支持满足以下两个条件的元组类型之间的赋值： 两个元组类型有相同数量的元素 对于每个元组位置，右侧元组元素的类型与左侧相应的元组元素的类型相同或可以隐式转换为左侧相应的元组元素的类型 还可以使用赋值运算符 = 在单独的变量中析构元组实例。 为此，可以使用以下方式之一进行操作： 在括号内显式声明每个变量的类型： 12345var t = (&quot;post office&quot;, 3.6);(string destination, double distance) = t;Console.WriteLine($&quot;Distance to {destination} is {distance} kilometers.&quot;);// Output:// Distance to post office is 3.6 kilometers. 在括号外使用 var 关键字来声明隐式类型化变量，并让编译器推断其类型： 12345var t = (&quot;post office&quot;, 3.6);var (destination, distance) = t;Console.WriteLine($&quot;Distance to {destination} is {distance} kilometers.&quot;);// Output:// Distance to post office is 3.6 kilometers. 使用现有变量： 12345678var destination = string.Empty;var distance = 0.0;var t = (&quot;post office&quot;, 3.6);(destination, distance) = t;Console.WriteLine($&quot;Distance to {destination} is {distance} kilometers.&quot;);// Output:// Distance to post office is 3.6 kilometers. 元组相等从 C# 7.3 开始，元组类型支持 == 和 != 运算符。 这些运算符按照元组元素的顺序将左侧操作数的成员与相应的右侧操作数的成员进行比较。 123456789(int a, byte b) left = (5, 10);(long a, int b) right = (5, 10);Console.WriteLine(left == right); // output: TrueConsole.WriteLine(left != right); // output: Falsevar t1 = (A: 5, B: 10);var t2 = (B: 5, A: 10);Console.WriteLine(t1 == t2); // output: TrueConsole.WriteLine(t1 != t2); // output: False 同时满足以下两个条件时，两个元组可比较： 两个元组具有相同数量的元素。 例如，如果 t1 和 t2 具有不同数目的元素，t1 != t2 则不会进行编译。 对于每个元组位置，可以使用 == 和 != 运算符对左右侧元组操作数中的相应元素进行比较。 例如，(1, (2, 3)) == ((1, 2), 3) 不会进行编译，因为 1 不可与 (1, 2) 比较。 == 和 != 运算符将以短路方式对元组进行比较。 也就是说，一旦遇见一对不相等的元素或达到元组的末尾，操作将立即停止。 但是，在进行任何比较之前，将对所有元组元素进行计算，如以下示例所示： 12345678910111213Console.WriteLine((Display(1), Display(2)) == (Display(3), Display(4)));int Display(int s){ Console.WriteLine(s); return s;}// Output:// 1// 2// 3// 4// False 可以为null的值类型可为 null 值类型 T? 表示其基础值类型 T 的所有值及额外的 null 值。 例如，可以将以下三个值中的任意一个指定给 bool? 变量：true、false 或 null。 基础值类型 T 本身不能是可为空的值类型。 引用类型内置的引用类型有object、dynamic和string。Object类型是C#通用类型系统中所有数据类型的终极基类。Object是System.Object类的别名。Object类型可以在类型转换之后被分配任何其他类型的值（编译时检查）。任何类型的值都可以存储在动态数据类型变量中。这些变量的类型检查在运行时发生。String类型可以被分配任何字符串的值。String是System.String类的别名。 内置引用类型object类型object类型是System.Object的别名，所有类型都直接或者间接的从System.Object类型派生。值类型转换为object类型的过程被称为装箱，object类型转换为值类型的过程被称为取消装箱。 string类型string类型是Unicode字符的集合，是System.String的别名。使用==和!=比较Unicode集合的值是否相等，使用Object.ReferenceEquals()比较引用值本身是否相等。逐字字符串以@开头，不处理转义序列。若要在 @-quoted 字符串中包含双引号，双倍添加即可： 1@&quot;&quot;&quot;Ahoy!&quot;&quot; cried the captain.&quot; // &quot;Ahoy!&quot; cried the captain. delegate类型delegate类型的声明和method signature相似。有一个返回值和任意数目的参数列表。delegate用于封装命名方法或者匿名方法的引用类型，类似于函数指针。委托是类型安全的。 dynamic类型dynamic 类型表示变量的使用和对其成员的引用绕过编译时类型检查。 改为在运行时解析这些操作。 dynamic 类型简化了对 COM API（例如 Office Automation API）、动态 API（例如 IronPython 库）和 HTML 文档对象模型 (DOM) 的访问。 classC#只允许单一继承，但是一个类可以实现多个接口。 interface从C# 8.0开始，接口可为成员定义默认实现。 它还可以定义static成员，以便提供常见功能的单个实现。 可为null的引用类型在可为 null 的感知上下文中： 引用类型 T 的变量必须用非 null 值进行初始化，并且不能为其分配可能为 null 的值。 引用类型 T? 的变量可以用 null 进行初始化，也可以分配 null，但在取消引用之前必须对照 null 进行检查。 类型为 T? 的变量 m 在应用 null 包容运算符时被认为是非空的，如 m! 中所示。 参考资料 C#教程 菜鸟教程 C#入门经典 C#指南 语言参考","link":"/2020/11/28/C-%E7%B1%BB%E5%9E%8B/"},{"title":"DApp开发环境配置指南","text":"由于区块链与数字货币这门课程给的指导教程涉及的各种库的版本都比较旧，有的甚至连接口都已经变化，导致实际的开发过程中踩了很多的坑，特此编写此指南来对其中的开发环境配置进行说明。 项目依赖的开发工具Truffle 和 Ganache CLI如果在本地环境下进行DApp的开发，那么我们就需要一个好用的本地环境来进行智能合约的部署，首先我们需要一个本地的ETH区块链环境，Ganache CLI是一个很好的选择。要将智能合约部署到Ganache CLI启动的区块链上，我们还需要一个工具来帮助我们进行智能合约的编译，这个工具就是Truffle，它会把智能合约编译为一个JSON文件，其中包含ABI，bytecode等各种部署时需要的参数。 Web3为了便利Web端和区块链进行交互，我们需要一个JS API来实现这个功能，他就是web3.js，它提供了各种接口来实现和区块链以及智能合约的交互。 Metamask如果我们的Web端需要和特定的ETH账户交互，我们需要实现一系列复杂的功能，好在Metamask帮我们处理好了这一切，我们只需要在Metamask中配置好自己的钱包以及私钥，然后在JS中对其进行调用就可以实现转账，扣款等功能。 REMIX当你的智能合约编写好之后，有很多方法都可以对它进行测试，但是笔者认为最便利的方法就是利用在线IDE REMIX来对其进行调试，笔者本身对这种在线的IDE也不是很感冒，但是在尝试过REMIX之后，我彻底的改变了这种想法。笔者在开发的最开始阶段，坚定的通过code review和编写truffle测试脚本的方式来对写好的智能合约进行调试，这种方法不仅效率低，执行还慢，还容易出现一堆烦人的问题，在换到了REMIX之后，这些问题全都迎刃而解，REMIX可以直接跟本地的Ganache区块链进行交互，并通过可视化的方式对智能合约中的各种函数进行调用，总之就是非常的好用，推荐读者们试一试。 工具链的配置在上述工具都妥善的安装好之后，我们就可以将他们配置成一个工具链了。按照以下的步骤逐步进行开发环境的部署，如果顺利的话，很快就可以拥有一个本地的，高效的ETH开发环境。 配置Ganache CLIGanache CLI可以通过默认的方式ganache-cli直接在终端中启动，但是由于Ganche是运行在内存中的，每次启动时Ganache中都是一个全新的区块链，会生成全新的账号，全新的钱包，这对于我们的开发调试来说非常的不方便。但是好在ganache-cli手动配置账号的私钥，ganache-cli --account=&quot;&lt;private-key&gt;,&lt;balance&gt;&quot;就可以配置一个指定私钥和余额的账户，而且--account参数可以输入任意多次，那么我们就可以直接将ganache-cli启动时生成的私钥写死，这样就不用每次重启ganache都需要去metamask中修改配置了。一个启动脚本的例子如下所示 123456789101112#!/bin/bashganache-cli -h 127.0.0.1 -p 8545 \\--account=&quot;0x09d41b29574cb6b4200c4245321f1b7a618336b8bd0bb0580c9e074aa9c7858a,0x56BC75E2D63100000&quot; \\--account=&quot;0x7cec80d21399baa0e1eff40ef3be1f3a55d4d369591111fb370562e55e346d2b,0x56BC75E2D63100000&quot; \\--account=&quot;0xee97670fc3b192248c3bff2903aee96f05843428341d0e28da9e746b9802f09b,0x56BC75E2D63100000&quot; \\--account=&quot;0xe7e130dc9d4d2905cd55a8bddb05eb21d5a371d7dfe75a63c444d6e657c301e9,0x56BC75E2D63100000&quot; \\--account=&quot;0xf252aaf70394a5d477f97485472601ca3215b7c015ac5875a34b321e003179fb,0x56BC75E2D63100000&quot; \\--account=&quot;0xd13464415601336377f4d146c527f37444ac5bff740b190fdb119c0629edf870,0x56BC75E2D63100000&quot; \\--account=&quot;0x9c68cab31e45311979f1fd305e77d673a03a2c1389d8c6357603267110cb4bf2,0x56BC75E2D63100000&quot; \\--account=&quot;0x7cba3617446f12057313d101d03e31736a56bd7b06c62d9d33e62816dc71c334,0x56BC75E2D63100000&quot; \\--account=&quot;0x3ab22c3f21864b3538c11d1d6d2b6a200266c2d509ba307db260f8deaafb8a04,0x56BC75E2D63100000&quot; \\--account=&quot;0x7a78a4dc8977da3647cce27a2cbe84c1b0012eaec6f56f170ae1a4dddd2f2b2e,0x56BC75E2D63100000&quot; 上述配置会在127.0.0.1:8545启动一个区块链，并生成十个账号，每个账号的余额是100ETH，值得注意的是balance参数的值是一个十六进制数，它的单位是WEI。 配置Metamask上述指定密钥生成区块链配置的方法会产生一个问题，那就是Ganache不再为我们生成钱包，所以我们就需要在Metamask中进行钱包的配置。 注意Metamask为钱包生成的密语一定要保存好，不然以后恢复不到测试的钱包账号了 之后会进入到Metamask的主界面，在右上角添加一个自定义RPC 自定义RPC的配置如下 点击保存之后Metamask就能连接到Ganache提供的RPC网络上了，现在你会发现默认的Account 1的余额是0ETH，这是因为这个账号不在Ganache区块链上，这时候我们将之前配置好的十个账号私钥中随便挑一个添加到Ganche中就大功告成了。 配置REMIX配置了一大堆之后我们终于可以进行智能合约的部署和测试了，现在我们打开REMIX，首先进行最重要的配置给Remix挑选一款喜欢的主题 然后再Remix中新建一个文件，把写好的智能合约粘贴进去，之后先点击编译 然后在部署界面将ENVIRONMENT选项配置为Web3 Provider也就是本地的Ganche CLI启动的RPC网络，然后点击Deploy就能将合约部署到Ganache CLI上了。 Web3与智能合约的交互Web3的文档中明确的定义了Web3的各种交互行为，这里说以下如何获取Metamask注入到浏览器中的Web3 Provider以及如何获取Metamask授权的账号 123456789101112131415161718192021222324let getWeb3 = async function () { var provider var address if(window.ethereum) { provider = window.ethereum try { await window.ethereum.enable() } catch (error) { console.error(&quot;User denied account access&quot;) } var web3 = new Web3(provider) await web3.eth.getAccounts(function (error, result) { if (!error) { address = result } }) return new Array(web3, address[0]) } else { alert(&quot;ERROR! metamask not installed!&quot;) }} 一个获取Metamask注入Provider的函数就如同上面的代码所示window.ethereum就是Metamask注入的web3 provider，window.ethereum.enable()这个调用会启动Metamask的认证流程，当认证通过之后，就能获取到授权账号的地址了。","link":"/2021/01/07/DApp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"},{"title":"Git 重命名文件和文件夹","text":"之前在git管理的项目中重命名文件和文件夹一直使用mv指令，例如： 123mv -r folder1 folder2git add .git commit &quot;...&quot; 这样会存在一个很大的问题，那就是这整个文件夹中的git历史信息删除掉了。正确的做法应该是： 文件夹 123git mv -f folder1 folder2git add -u folder2git commit -m &quot;...&quot; 文件 12git mv file1 file2git commit -m &quot;...&quot;","link":"/2020/12/11/Git-%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"title":"LeetCode 42","text":"思路经典的双指针问题，首先让左右两指针分别指向数组的头和尾，并维护两个变量，left_max和right_max用来存储当前左侧和右侧的最大值。假设，当前左侧的柱形高度低于右侧，那么如果左侧的柱形低于left_max的高度，那么当前柱形的上方一定能积水，否则，一定没有积水，那么我们就将left_max的高度更新为当前柱形的高度。右侧同理。那么用此方法，使用双指针遍历完所有的柱形之后，总的积水量就可以得出来了。 代码12345678910111213141516171819202122class Solution {public:int trap(vector&lt;int&gt;&amp; height){ int left = 0, right = height.size() - 1; int ans = 0; int left_max = 0, right_max = 0; while (left &lt; right) { if (height[left] &lt; height[right]) { height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]); ++left; } else { height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]); --right; } } return ans;}}; 参考资料 42. 接雨水","link":"/2020/11/11/LeetCode-42/"},{"title":"Lua 快速入门","text":"Lua 数据类型Lua是动态类型的语言，不需要给变量声明类型。Lua有8个基本类型： 数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 Lua 变量Lua 变量有三种类型：全局变量、局部变量和表中的域。Lua 变量默认为全局变量，除非用local显式声明为局部变量。局部变量的作用域从声明位置开始到所在语句块结束。变量的默认值都是nil。 Lua 循环for 循环数值 for 循环123for var=exp1, exp2, exp3 do &lt;...&gt;end var从exp1变化到exp2，每次以exp3为步长递增var，如果exp3缺省，则默认为1。 泛型 for 循环使用一个迭代器来遍历所有的值 1234a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}for i, v in ipairs(a) do print(i, v)end i是数组索引值，v是对应索引的数组元素值，ipairs是Lua提供的迭代器，用来迭代数组。 while 循环1234while(condition)do statementsend repeat…until 循环123repeat statementsuntil( condition ) Lua 流程控制if 语句1234if(布尔表达式)then --[ 在布尔表达式为 true 时执行的语句 --]end if…else 语句123456if(布尔表达式)then --[ 布尔表达式为 true 时执行该语句块 --]else --[ 布尔表达式为 false 时执行该语句块 --]end if…elseif…else 语句1234567891011121314if( 布尔表达式 1)then --[ 在布尔表达式 1 为 true 时执行该语句块 --]elseif( 布尔表达式 2)then --[ 在布尔表达式 2 为 true 时执行该语句块 --]elseif( 布尔表达式 3)then --[ 在布尔表达式 3 为 true 时执行该语句块 --]else --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]end Lua 函数定义的格式1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separatedend optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。 function_name: 指定函数名称。 argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body: 函数体，函数中需要执行的代码语句块。 result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。 函数调用 一般形式func(&lt;para&gt;)，圆括号是必须的 当函数只有一个参数，并且此参数为字面字符串或者table构造式的时候，圆括号可以缺省 当实参少于形参的时候，不足的形参会以nil不足 当实参多于形参的时候，多余的实参会被抛弃 将函数作为参数传递给函数123456789101112myprint = function(param) print(&quot;这是打印函数 - ##&quot;,param,&quot;##&quot;)endfunction add(num1,num2,functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result)endmyprint(10)-- myprint 函数作为参数传递add(2,5,myprint) 返回多个结果值。12345678910111213function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendprint(maximum({8,10,23,12,5})) 可变参数12345678function add(...) local s = 0 for i, v in ipairs{...} do --&gt; {...} 表示一个由所有变长参数构成的数组 s = s + v end return s end print(add(3,4,5,6,7)) ---&gt;25 Lua 运算符 操作符 描述 + 加法 - 减法 * 乘法 / 除法 % 取余 ^ 乘幂 操作符 描述 == 等于，检测两个值是否相等，相等返回 true，否则返回 false ~= 不等于，检测两个值是否相等，不相等返回 true，否则返回 false &gt; 大于，如果左边的值大于右边的值，返回 true，否则返回 false &lt; 小于，如果左边的值大于右边的值，返回 false，否则返回 true &gt;= 大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false &lt;= 小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false 操作符 描述 and 逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。 or 逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。 not 逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。 操作符 描述 .. 连接两个字符串 # 一元运算符，返回字符串或表的长度。 Lua 迭代器泛型for迭代器泛型for在自己内部保存迭代函数，实际上它保存三个值：迭代函数，状态常量，控制变量。 123456array = {&quot;Google&quot;, &quot;Runoob&quot;}for key,value in ipairs(array)do print(key, value)end 首先，计算in之后的表达式的值，表达式会返回for需要的三个值：迭代函数、状态常量和控制变量，如果表达式返回的结果个数不足三个会用nil补足，多出的部分会被忽略。 第二，将状态常量和控制变量作为参数调用迭代函数。 第三，将迭代函数返回的值赋给变量列表。 第四，如果返回的第一个值为nil循环结束，否则执行循环体。 第五，回到第二步再次调用迭代函数 无状态的迭代器无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。 多状态的迭代器很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。 Lua tableLua table是关联型数组，可以使用nil之外任意类型的值来索引。table可以使用以下操作： 序号 方法 &amp; 用途 1 table.concat (table [, sep [, start [, end]]]): concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。 2 table.insert (table, [pos,] value): 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. 3 table.remove (table [, pos]) 返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。 4 table.sort (table [, comp]) 对给定的table进行升序排序。 Lua metatable1234mytable = {} -- 普通表mymetatable = {} -- 元表setmetatable(mytable,mymetatable) -- 把 mymetatable 设为 mytable 的元表mytable = setmetatable({},{}) -- 另一种可行的写法 Lua 协程Lua 协程和线程类似，拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。 Lua 错误处理assert可以使用两个函数：assert和error来处理错误： 123456local function add(a,b) assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;) assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;) return a+bendadd(10) assert首先检查第一个参数，如果没问题，就执行下一行语句，如果第一个参数出错，就将第二个参数作为错误信息抛出。 errorerror函数终止正在执行的函数，并返回message的内容作为错误信息。 1error (message [, level]) Level=1[默认]：为调用error位置(文件+行号) Level=2：指出哪个调用error的函数的函数 Level=0:不添加错误位置信息 pcall函数pcall（protected call）来包装需要执行的代码。pcall接受一个函数和一个需要传递给函数的参数。执行结果如下： 结果 返回值 无错误 true 有错误 false, errorinfo xpcallLua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。debug库提供了两个通用的错误处理函数: debug.debug：提供一个Lua提示符，让用户来检查错误的原因 debug.traceback：根据调用桟来构建一个扩展的错误消息 12345678910function myfunction () n = n/nilendfunction myerrorhandler( err ) print( &quot;ERROR:&quot;, err )endstatus = xpcall( myfunction, myerrorhandler )print( status) 参考资料 Lua 教程 Lua中assert( )函数的使用 lua自定义排序函数","link":"/2020/12/02/Lua%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"Approximation","text":"Polynomial-time approximation schemeIn computer science, a polynomial-time approximation scheme (PTAS) is a type of approximation algorithm for optimization problems (most often, NP-hard optimization problems). A PTAS is an algorithm which takes an instance of an optimization problem and a parament $\\epsilon &gt; 0$ and, in polynomial time, produces a solution that is within a factor $1 + \\epsilon$ of being optimal (or $1 - \\epsilon$ for maximization problems). Or, we can say for any fixed $\\epsilon &gt; 0$, the scheme runs in polynomial time in the size $n$ of its input instance. The running time of a PTAS is required to be polynomial in n for every fixed $\\epsilon$ but can be different for different $\\epsilon$. For example consider a minimization problem, if $\\epsilon$ is 0.5, then the solution provided by the PTAS algorithm is 1.5-approximate. The running time of PTAS must be polynomial in terms of n. But it can be exponential in terms of $\\epsilon$. Fully polynomial-time approximation schemeIn PTAS algorithms, the exponent of the polynomial can increase dramatically as ε reduces, for example if the runtime is $O(n^{(1/\\epsilon)!})$ which is a problem. So we need a stricter scheme. Fully polynomial-time approximation scheme(FPTAS) requires the algorithm to be polynomial time in both the problem size $n$ and $1/\\epsilon$. All problems in FPTAS are fixed-parameter tractable. Both the knapsack problem and bin pack problem admit an FPTAS. Bin packing problemGiven n items of different weights and bins each of capacity c, assign each item to a bin such that number of total used bins is minimized. It may be assumed that all items have weights smaller than bin capacity. Lower boundWe can always find a lower bound on minimum number of bins required. The lower bound can be given as $$Min\\ no.\\ of\\ bins &gt;= Ceil ((Total\\ Weight) / (Bin\\ Capacity))$$ Online algorithmsNext fitWhen processing next item, check if it fits in the same bin as the last item. Use a new bin only if it does not. Next Fit is 2-approximate, i.e., the number of bins used by this algorithm is bounded by twice of optimal. Consider any two adjacent bins. The sum of items in these two bins must be bigger than the comtent; otherwise, NextFit would have put all the items of second bin into the first. The same holds for all other bins. Thus, at most half the space is wasted, and so Next Fit uses at most 2M bins if M is optimal. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std; // Returns number of bins required using next fit // online algorithm int nextFit(int weight[], int n, int c) { // Initialize result (Count of bins) and remaining // capacity in current bin. int res = 0, bin_rem = c; // Place items one by one for (int i=0; i&lt;n; i++) { // If this item can't fit in current bin if (weight[i] &gt; bin_rem) { res++; // Use a new bin bin_rem = c - weight[i]; } else bin_rem -= weight[i]; } return res; } // Driver program int main() { int weight[] = {2, 5, 4, 7, 1, 3, 8}; int c = 10; int n = sizeof(weight) / sizeof(weight[0]); cout &lt;&lt; &quot;Number of bins required in Next Fit : &quot; &lt;&lt; nextFit(weight, n, c); return 0; } First fitWhen processing the next item, see if it fits in the same bin as the last item. Start a new bin only if it does not. If M is the optimal number of bins, then First Fit never uses more than 1.7M bins. So First Fit is better than Next Fit in terms of upper bound on number of bins. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std; // Returns number of bins required using first fit // online algorithm int firstFit(int weight[], int n, int c) { // Initialize result (Count of bins) int res = 0; // Create an array to store remaining space in bins // there can be at most n bins int bin_rem[n]; // Place items one by one for (int i=0; i&lt;n; i++) { // Find the first bin that can accommodate // weight[i] int j; for (j=0; j&lt;res; j++) { if (bin_rem[j] &gt;= weight[i]) { bin_rem[j] = bin_rem[j] - weight[i]; break; } } // If no bin could accommodate weight[i] if (j==res) { bin_rem[res] = c - weight[i]; res++; } } return res; } // Driver program int main() { int weight[] = {2, 5, 4, 7, 1, 3, 8}; int c = 10; int n = sizeof(weight) / sizeof(weight[0]); cout &lt;&lt; &quot;Number of bins required in First Fit : &quot; &lt;&lt; firstFit(weight, n, c); return 0; } 0-1 knapsack problemWe know that 0-1 knapsack is NP Complete. There is a DP based pseudo polynomial solution for this. But if input values are high, then the solution becomes infeasible and there is a need of approximate solution. One approximate solution is to use Greedy Approach (compute value per kg for all items and put the highest value per kg first if it is smaller than W), but Greedy approach is not PTAS, so we don’t have control over accuracy. Below is a FPTAS solution for 0-1 Knapsack problem: Input: W (Capacity of Knapsack) val[0..n-1] (Values of Items) wt[0..n-1] (Weights of Items) Solution: Find the maximum valued item, i.e., find maximum value in val[]. Let this maximum value be maxVal. Compute adjustment factor k for all values1k = (maxVal * ε) / n Adjust all values, i.e., create a new array val’[] that values divided by k. Do following for every value val[i].1val'[i] = floor(val[i] / k) Run DP based solution for reduced values, i,e, val’[0..n-1] and all other parameter same. The above solution works in polynomial time in terms of both n and ε. The solution provided by this FPTAS is $(1 - \\epsilon)-approximate$. The idea is to rounds off some of the least significant digits of values then they will be bounded by a polynomial and $1/\\epsilon$.","link":"/2019/05/15/approximation/"},{"title":"B+-trees","text":"What is a B+-treeMost queries can be executed more quickly if the values are stored in order. But it’s not practical to hope to store all the rows in the table one after another, in sorted order, because this requires rewriting the entire table with each insertion or deletion of a row. This leads us to instead imagine storing our rows in a tree structure. Our first instinct would be a balanced binary search tree like a red-black tree, but this really doesn’t make much sense for a database since it is stored on disk. You see, disks work by reading and writing whole blocks of data at once — typically 512 bytes or four kilobytes. A node of a binary search tree uses a small fraction of that, so it makes sense to look for a structure that fits more neatly into a disk block. Hence the B+-tree, in which each node stores up to $d$ references to children and up to $d$ − 1 keys. Each reference is considered “between” two of the node’s keys; it references the root of a subtree for which all values are between these two keys. Here is a fairly small tree using 4 as our value for $d$. A B+-tree requires that each leaf be the same distance from the root, as in this picture, where searching for any of the 11 values (all listed on the bottom level) will involve loading three nodes from the disk (the root block, a second-level block, and a leaf). In practice, d will be larger — as large, in fact, as it takes to fill a disk block. Suppose a block is 4KB, our keys are 4-byte integers, and each reference is a 6-byte file offset. Then we’d choose d to be the largest value so that 4 (d − 1) + 6 d ≤ 4096; solving this inequality for d, we end up with d ≤ 410, so we’d use 410 for d. As you can see, d can be large. A B+-tree maintains the following invariants: Every node has one more references than it has keys. All leaves are at the same distance from the root. For every non-leaf node $N$ with $k$ being the number of keys in $N$: all keys in the first child’s subtree are less than $N’s$ first key; and all keys in the ith child’s subtree (2 ≤ $i$ ≤ $k$) are between the ($i$ − 1)th key of n and the ith key of n. The root has at least two children. Every non-leaf, non-root node has at least $\\lceil d / 2 \\rceil$ children. Each leaf contains at least $\\lceil d / 2 \\rceil$ keys. Every key from the table appears in a leaf, in left-to-right sorted order. Node Type Children Type Min Number of Children Max Number of Children Example($b$ = 7) Example($b$ = 100) Root Node (when it is the only node in the tree) Records 1 $d$ - 1 1-6 1–99 Root Node Internal Nodes or Leaf Nodes 2 $d$ 2–7 2–100 Internal Node Internal Nodes or Leaf Nodes $\\lceil d / 2 \\rceil$ $d$ 4–7 50–100 Leaf Node Records $\\lceil d / 2 \\rceil$ $d$ 4–7 50–100 InsertionDescend to the leaf where the key fits. If the node has an empty space, insert the key/reference pair into the node. If the node is already full, split it into two nodes, distributing the keys evenly between the two nodes. If the node is a leaf, take a copy of the minimum value in the second of these two nodes and repeat this insertion algorithm to insert it into the parent node. If the node is a non-leaf, exclude the middle value during the split and repeat this insertion algorithm to insert this excluded value into the parent node. DeletionDescend to the leaf where the key exists. Remove the required key and associated reference from the node. If the node still has enough keys and references to satisfy the invariants, stop. If the node has too few keys to satisfy the invariants, but its next oldest or next youngest sibling at the same level has more than necessary, distribute the keys between this node and the neighbor. Repair the keys in the level above to represent that these nodes now have a different “split point” between them; this involves simply changing a key in the levels above, without deletion or insertion. If the node has too few keys to satisfy the invariant, and the next oldest or next youngest sibling is at the minimum for the invariant, then merge the node with its sibling; if the node is a non-leaf, we will need to incorporate the “split key” from the parent into our merging. In either case, we will need to repeat the removal algorithm on the parent node to remove the “split key” that previously separated these merged nodes — unless the parent is the root and we are removing the final key from the root, in which case the merged node becomes the new root (and the tree has become one level shorter than before). ExampleInitial: Insert 9: Insert 10: Insert 8: Delete 23: Delete 19:","link":"/2019/05/18/bplus-trees/"},{"title":"C# 关键字","text":"修饰符访问修饰符访问修饰符共有四个 public protected internal private 可以定义六个可访问性级别 声明的可访问性 访问范围 public 不受限制 protected 包含类或派生于包含类的类型 internal 当前程序集 protected internal 当前程序集或派生自包含类的类型 private 包含类 private protected 包含类或当前程序集中派生自包含类的类型 命名空间中不能出现访问修饰符。如果没有在成员声明中指定访问修饰符，则使用默认的可访问性。 未嵌套在其他类型中的顶级类型只能具有 internal 或 public 可访问性。 这些类型的默认可访问性为 internal。 成员 默认成员可访问性 允许的成员的声明的可访问性 enum public 无 class private publicprotectedinternalprivateprotected internalprivate protected interface public 无 struct private public internalprivate abstract在类声明中庸abstract修饰符来指示某个类仅用于其他类的基类，不能用于自行实例化。abstract修饰的成员函数必须被派生类实现。 async将方法，lambda表达式或匿名方法指定为异步。 const使用 const 关键字来声明某个常量字段或常量局部变量。 常量字段和常量局部变量不是变量并且不能修改。 常量可以为数字、布尔值、字符串或 null 引用。 event声明发布服务器类中的事件 external声明在外部实现的方法 in（泛型修饰符）对于泛型类型参数，in 关键字可指定类型参数是逆变的。 可以在泛型接口和委托中使用 in 关键字。 逆变使你使用的类型可以比泛型参数指定的类型派生程度更小。 这样可以隐式转换实现协变接口的类以及隐式转换委托类型。 引用类型支持泛型类型参数中的协变和逆变，但值类型不支持它们。 new（成员修饰符）在用作声明修饰符时，new 关键字可以显式隐藏从基类继承的成员。 隐藏继承的成员时，该成员的派生版本将替换基类版本。 out（泛型修饰符）对于泛型类型参数，out 关键字可指定类型参数是协变的。 可以在泛型接口和委托中使用 out 关键字。 协变使你使用的类型可以比泛型参数指定的类型派生程度更大。 这样可以隐式转换实现协变接口的类以及隐式转换委托类型。 引用类型支持协变和逆变，但值类型不支持它们。 override扩展或修改继承的方法、属性、索引器或事件的抽象或虚拟实现需要 override 修饰符。不能重写非虚方法或静态方法。 重写基方法必须是 virtual、abstract 或 override。 override 声明不能更改 virtual 方法的可访问性。 override 方法和 virtual 方法必须具有相同级别访问修饰符。 randonlyreadonly 关键字是一个可在四个上下文中使用的修饰符： 在字段声明中，readonly 指示只能在声明期间或在同一个类的构造函数中向字段赋值。 可以在字段声明和构造函数中多次分配和重新分配只读字段。 由于值类型直接包含数据，因此属于readonly值类型的字段不可变。 由于引用类型包含对其数据的引用，因此属于 readonly 引用类型的字段必须始终引用同一对象。 该对象是可变的。 readonly 修饰符可防止字段替换为引用类型的其他实例。 但是，修饰符不会阻止通过只读字段修改字段的实例数据。 包含属于可变引用类型的外部可见只读字段的外部可见类型可能存在安全漏洞，可能会触发警告 CA2104：“不要声明只读可变引用类型。” 在 readonly struct 类型定义中，readonly 指示结构类型是不可变的。 在结构类型内的实例成员声明中，readonly 指示实例成员不修改结构的状态。 在 ref readonly 方法返回中，readonly 修饰符指示该方法返回一个引用，且不允许向该引用写入内容。 sealed应用于某个类时，sealed 修饰符可阻止其他类继承自该类。 static使用 static 修饰符可声明属于类型本身而不是属于特定对象的静态成员。 static 修饰符可用于声明 static 类。static 修饰符不能用于索引器或终结器。static可以用于声明静态类，静态类无法被实例化。 unsafeunsafe关键字用于表示不安全上下文。 virtualvirtual 关键字用于修改方法、属性、索引器或事件声明，并使它们可以在派生类中被重写。virtual 修饰符不能与 static、abstract private 或 override 修饰符一起使用。 volatilevolatile 关键字指示一个字段可以由多个同时执行的线程修改。 语句关键字方法参数为不具有 in、ref 或 out 的方法声明的参数会按值传递给调用的方法。 可以在方法中更改该值，但当控制传递回调用过程时，不会保留更改后的值。 可以通过使用方法参数关键字更改此行为。 params使用 params 关键字可以指定采用数目可变的参数的方法参数。 参数类型必须是一维数组。 在方法声明中的 params 关键字之后不允许有任何其他参数，并且在方法声明中只允许有一个 params 关键字。 in（参数修饰符）in 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 in 参数无法通过调用的方法进行修改，相当于一个readonly的引用。 refref 关键字指示按引用传递的值。 它用在四种不同的上下文中： 在方法签名和方法调用中，按引用将参数传递给方法。 在方法签名中，按引用将值返回给调用方。 在成员正文中，指示引用返回值是否作为调用方欲修改的引用被存储在本地，或在一般情况下，局部变量按引用访问另一个值。 在 struct 声明中声明 ref struct 或 readonly ref struct。 按引用传递参数在方法的参数列表中使用 ref 关键字时，它指示参数按引用传递，而非按值传递。 ref 关键字让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 例如，如果调用方传递本地变量表达式或数组元素访问表达式，所调用方法会替换 ref 参数引用的对象，然后，当该方法返回时，调用方的本地变量或数组元素将开始引用新对象。 不要混淆通过引用传递的概念与引用类型的概念。 这两种概念是不同的。 无论方法参数是值类型还是引用类型，均可由 ref 修改。 当通过引用传递时，不会对值类型装箱。 若要使用 ref 参数，方法定义和调用方法均必须显式使用 ref 关键字。 引用返回值引用返回值（或 ref 返回值）是由方法按引用向调用方返回的值。 即是说，调用方可以修改方法所返回的值，此更改反映在调用方法中的对象的状态中。 ref局部变量ref 局部变量用于指代使用 return ref 返回的值。 无法将 ref 局部变量初始化为非 ref 返回值。 也就是说，初始化的右侧必须为引用。 out（参数修饰符）out 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 若要使用 out 参数，方法定义和调用方法均必须显式使用 out 关键字。 命名空间关键字类型测试关键字泛型类型约束关键字new约束new 约束指定泛型类声明中的类型实参必须有公共的无参数构造函数。 若要使用 new 约束，则该类型不能为抽象类型。 当与其他约束一起使用时，new() 约束必须最后指定。 where（泛型类型约束）泛型定义中的 where 子句指定对用作泛型类型、方法、委托或本地函数中类型参数的参数类型的约束。 约束可指定接口、基类或要求泛型类型为引用、值或非托管类型。 它们声明类型参数必须具备的功能。 访问关键字base从派生类中访问基类的成员 调用基类上已被其他方法重写的方法。 指定创建派生类实例时应调用的基类构造函数。 thisthis 关键字指代类的当前实例，还可用作扩展方法的第一个参数的修饰符。 文字关键字null、true、false和default 上下文关键字查询关键字参考资料 C# 关键字","link":"/2020/12/01/csharp%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"关系数据库设计","text":"数据库设计与E-R模型实体-联系模型实体集&amp;联系集实体-联系（entity-relationship，E-R）。实体表示现实世界中可区别于所有其他对象的的一个“事物”或“对象”。每个实体有一组性质，其中一些性质的值可以唯一的标示一个实体。实体集（entity set）是具有相同类型的一个实体集合。外延（extension）指属于实体集的实体的实际的集合。实体通过一组属性（attribution）来表示，每个属性有一个值（value）。 联系（relationship）指多个实体间的相互关联。联系集（relationship set）是相同类型联系的集合。实体集之间的关联称为参与（participation）。 属性每个属性都有一个可以取值的范围称为该属性的域（domain）。属性可以如下划分： 简单（simple）和复合（composite）属性 单值（single-valued）和多值（multiple-valued）属性 派生（derived）属性 约束映射基数（mapping cardinality）对于二元关系，映射基数必然是以下情况 一对一（one-to-one） 一对多（one-to-many） 多对一（many-to-one） 多对多（many-to-many） 参与约束实体集（E），联系集（R）。E中的每个实体都参与到R的至少一个联系中，E到R的参与称为全部（total）。如果只有部分参与，称为部分（partial）。 码R是一个涉及实体集$E_1, E_2, …, E_n$的联系集。$primary-key(E_i)$代表$E_i$的主码。R的主码构成依赖于同R关联的属性的集合。 如果R没有属性与之关联$$primary-key(E_1) \\cup primary-key(E_2) \\cup … \\cup primary-key(E_n)$$描述了R中的一个联系 如果R有属性$a_1, a_2, …, a_m$与之关联$$primary-key(E_1) \\cup primary-key(E_2) \\cup … \\cup primary-key(E_n) \\cup {a_1, a_2, …, a_m}$$描述了R中的一个联系 在上述关系中$$primary-key(E_1) \\cup primary-key(E_2) \\cup … \\cup primary-key(E_n)$$是R的一个超码 从实体集中删除冗余属性当一个属性A在两个实体集中都出现时，若A是$E_1$的主码，而在$E_2$中出现，但不构成主码。那么A应该从$E_2$中移除。 实体联系图基本结构 分成两部分的矩形代表实体集 棱形代表联系集 未分割的矩形代表联系集的属性，主码带下划线 线段将实体集连接到联系集 虚线将联系集属性连接到联系集 双线表示一个实体集全部的参与到联系集中 双菱形代表连接到弱实体集的标志性联系集 映射基数 一对一：两侧各画一个箭头 一对多：画箭头到一的实体集，线段到多的实体集 多对一：同理 多对多：两侧都画线段 实体集和二元联系集之间的一条边可以有一个关联最大和最小的映射基数，用l..h表示。最大值为*代表没有限制。 复杂属性 缩进表示复合属性 “{example-attribute}”表示多值属性 “example-attribute”表示派生属性 角色在矩形与棱形之间的连线上进行标注来表示角色 非二元的实体联系集在非二元的联系集中，我们最多只允许一个箭头。 弱实体集没有足够的属性构成主码的实体集是弱实体集（weak entity set）。弱实体集必须与另一个属主实体集（owner entity set）关联才有意义。这个关系称为存在依赖（existence dependent）。该联系称为标示性联系（identify relationship）。标示性联系是弱实体集到标示实体集的多对一的关系，而且弱实体集的参与是全部的，标示性联系集不应该有任何描述性属性。弱实体集的主码由标示性实体集的主码加上分辨符组成。 分辨符用虚下划线表示 联系集用双菱形表示 关系数据库设计原子域与第一范式一个域是原子的（atomic），如果该域的元素被认为是不可分的单元。R是第一范式（First Normal Form， 1NF），如果R中所有属性的域都是原子的。 使用函数依赖进行分解 使用希腊字母表示属性集（e.g. $\\alpha$）。小写罗马字母后跟用圆括号括住的大写字母来表示关系模式（e.g. $r(R)$） 属性集是超码时用，用$K$表示 对关系使用小写名称 码和函数依赖一个关系的满足现实世界约束的实例，成为关系的合法实例（legal instance）。 令$r(R)$是一个关系模式。在关系$r(R)$的任何合法实例中，对于$r$的实例中的所有元组对$t_1$和$t_2$总满足，若$t_1 \\neq t_2$，则$t_1[K] \\neq t_2[K]$。 有$r(R)$，$\\alpha \\subseteq R$且$\\beta \\subseteq R$ 给定一个实例，满足函数依赖$\\alpha \\rightarrow \\beta$的条件是：对于所有元组对$t_1$和$t_2$，若$t_1[\\alpha]=t_2[\\alpha]$，则$t_1[\\beta]=t_2[\\beta]$ 若所有合法实例都满足函数依赖$\\alpha \\rightarrow \\beta$，该函数依赖在$r(R)$上成立 有以下两种方式使用函数依赖 判定关系的实例是否满足给定函数一俩集$F$ 说明合法关系上的约束 如果函数依赖在所有的关系中都满足，那么就称该函数关系是平凡（trival）的。给定关系$r(R)$上成立的函数依赖集$F$。使用$F^+$表示$F$集合的闭包（closure）。 Boyce-Codd Normal Form具有函数依赖集$F$的关系模式$R$属于BCNF的条件是，对$F^+$中所有的函数依赖$\\alpha \\rightarrow \\beta$ 函数依赖$\\alpha \\rightarrow \\beta$是平凡的 $\\alpha$是$R$的一个超码 设$R$为不属于BCNF的一个模式，存在非平凡的函数依赖$\\alpha \\rightarrow \\beta$。用以下两个模式取代$R$ $(\\alpha \\cup \\beta)$ $(R - (\\beta - \\alpha))$ 第三范式具有函数依赖集$F$的关系模式$R$属于3NF的条件是，对$F^+$中所有的函数依赖$\\alpha \\rightarrow \\beta$ $\\alpha \\rightarrow \\beta$是一个平凡的函数依赖 $\\alpha$是$R$的一个超码 $\\beta - \\alpha$中每个属性$A$都包含在$R$的一个候选码中 函数依赖理论函数依赖的闭包如果$R$中每一个满足$F$的实例也满足$f$，则$R$上的函数依赖$f$被$r$上的函数依赖集$F$逻辑蕴含（logically imply）。用大写罗马字母表示单个属性，$\\alpha\\beta$表示$\\alpha \\cup \\beta$。使用Armstrong’s axiom寻找逻辑蕴含的函数依赖。 自反律（reflexivity rule）。若$\\beta \\subseteq \\alpha$，则$\\alpha \\rightarrow \\beta$ 增补律（augmentation rule）。若$\\alpha \\rightarrow \\beta$，则$\\alpha\\gamma \\rightarrow \\beta\\gamma$ 传递律（transitivity rule）。若$\\alpha \\rightarrow \\beta$且$\\beta \\rightarrow \\gamma$，则$\\alpha \\rightarrow \\gamma$ 通过Armstrong’s axiom可以推出 合并律（union rule）。若$\\alpha \\rightarrow \\beta$且$\\alpha \\rightarrow \\gamma$，则$\\alpha \\rightarrow \\beta\\gamma$ 分解率（decomposition rule），若$\\alpha \\rightarrow \\beta\\gamma$，则$\\alpha \\rightarrow \\beta$且$\\alpha \\rightarrow \\gamma$ 伪传递律（pseudotransitivity rule），$\\alpha \\rightarrow \\beta$且$\\beta\\lambda \\rightarrow \\gamma$，则$\\alpha\\lambda \\rightarrow \\gamma$ 属性的闭包如果$\\alpha \\rightarrow B$，称属性$B$被$\\alpha$函数确定（functionally determine）。","link":"/2020/05/10/db_design/"},{"title":"NP-completeness","text":"NP, P, NP-complete and NP-HardTo solve the problem of NP-completeness. Firstly, we need to figure out what is NP, P, NP-complete and NP-Hard. PP is set of problems that can be solved by a deterministic Turing machine in Polynomial time. NPNP is set of decision problems that can be solved by a Non-deterministic Turing Machine in Polynomial time. P is subset of NP (any problem that can be solved by deterministic machine in polynomial time can also be solved by non-deterministic machine in polynomial time). Informally, NP is set of decision problems (a problem that can be posed as a yes-no question of the input values) which can be solved by a polynomial time via a “Lucky Algorithm”, a magical algorithm that always makes a right guess among the given set of choices. NP-completeA decision problem L is NP-complete if: L is in NP (Any given solution for NP-complete problems can be verified quickly, but there is no efficient known solution). Every problem in NP is reducible to L in polynomial time (Reduction is defined below). NP-HardA problem is NP-Hard if it follows property 2 mentioned above, doesn’t need to follow property 1. Therefore, NP-Complete set is also a subset of NP-Hard set. The prove of NP-completeFrom the definition of NP-complete, it appears impossible to prove that a problem L is NP-Complete. By definition, it requires us to that show every problem in NP is polynomial time reducible to L. Fortunately, there is an alternate way to prove it. The idea is to take a known NP-Complete problem and reduce it to L. If polynomial time reduction is possible, we can prove that L is NP-Complete by transitivity of reduction (If a NP-Complete problem is reducible to L in polynomial time, then all problems are reducible to L in polynomial time). So, we need to know the first problem solved as NP-complete. Boolean satisfiability problemBoolean satisfiability problem (sometimes called propositional satisfiability problem and abbreviated SATISFIABILITY or SAT) is the problem of determining if there exists an interpretation that satisfies a given Boolean formula. In other words, it asks whether the variables of a given Boolean formula can be consistently replaced by the values TRUE or FALSE in such a way that the formula evaluates to TRUE. If this is the case, the formula is called satisfiable. On the other hand, if no such assignment exists, the function expressed by the formula is FALSE for all possible variable assignments and the formula is unsatisfiable. For example, the formula “a AND NOT b” is satisfiable because one can find the values a = TRUE and b = FALSE, which make (a AND NOT b) = TRUE. In contrast, “a AND NOT a” is unsatisfiable. SAT is the first problem that was proven to be NP-complete. This means that all problems in the complexity class NP, which includes a wide range of natural decision and optimization problems, are at most as difficult to solve as SAT. There is no known algorithm that efficiently solves each SAT problem, and it is generally believed that no such algorithm exists; yet this belief has not been proven mathematically, and resolving the question of whether SAT has a polynomial-time algorithm is equivalent to the P versus NP problem, which is a famous open problem in the theory of computing. Unrestricted satisfiability (SAT)The proof shows how every decision problem in the complexity class NP can be reduced to the SAT problem for CNF formulas, sometimes called CNFSAT. A useful property of Cook’s reduction is that it preserves the number of accepting answers. For example, deciding whether a given graph has a 3-coloring is another problem in NP; if a graph has 17 valid 3-colorings, the SAT formula produced by the Cook–Levin reduction will have 17 satisfying assignments. NP-completeness only refers to the run-time of the worst case instances. Many of the instances that occur in practical applications can be solved much more quickly. See Algorithms for solving SAT below. SAT is trivial if the formulas are restricted to those in disjunctive normal form, that is, they are disjunction of conjunctions of literals. Such a formula is indeed satisfiable if and only if at least one of its conjunctions is satisfiable, and a conjunction is satisfiable if and only if it does not contain both x and NOT x for some variable x. This can be checked in linear time. Furthermore, if they are restricted to being in full disjunctive normal form, in which every variable appears exactly once in every conjunction, they can be checked in constant time (each conjunction represents one satisfying assignment). But it can take exponential time and space to convert a general SAT problem to disjunctive normal form; for an example exchange $\\vee$ and $\\wedge$ in the above exponential blow-up example for conjunctive normal forms.","link":"/2019/05/11/np-completeness/"},{"title":"坐标系统","text":"局部空间（Local Space）世界空间（World Space）观察空间（View Space）观察空间就是将对象的世界空间的坐标转换为观察者视野前面的坐标。 裁剪空间（Clip Space）正射投影透视投影 near clipping plane / far clipping plane：这两个截断平面限制了视野的深度范围。计算机只会渲染这两个平面之间的点，比 near clipping plane 更近的点，以及比 far clipping plane 更远的点都不会被渲染。 FovH/FovV：水平视角/竖直视角：这两个视角限制了横向和纵向的可视范围（frustum 视锥），在这两个角度之外的点都不会被渲染。 相机坐标系：在 OpenGL 中，以相机为坐标原点，观测方向定义为 z 轴的负方向（即视线是逆着z轴的）。相机坐标系是右手系。 标准化设备坐标（normalized device coordinates，NDC）：由于不同的显示设备尺寸、像素不同，为了方便适应不同设备，三维坐标 (x, y, z) 将会被归一化到 -1 到 1 之间。NDC 坐标系是左手系，它的x轴和y轴与相机坐标系方向相同，而z轴则和相机坐标系的z轴相反。 透视投影矩阵：将物体在相机坐标系下的坐标，映射为标准化设备坐标 (NDC)的矩阵。 从Local坐标系到NDC$$V_{clip} =M_{projection}\\cdot M_{view}\\cdot M_{world}\\cdot M_{local}$$ 参考资料 坐标系统 Perspective Projection Matrix 透视投影矩阵的推导","link":"/2020/12/21/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"},{"title":"探究C++迭代器失效问题","text":"起因在LeetCode上做题的时候遇到一道需要手动实现deque的题目，因为需要通过一个哈希表经过O(1)的时间来访问到deque中的每个节点。于是机智的我想到了通过iterator来访问节点的方法，但是出乎意料的是出现了内存访问问题。最后定位到问题出在通过哈希表中储存的iterator来访问内存中的内容时，指针已经失效了。 示例实际出问题的代码段比较复杂，下面是它的逻辑简化版本 12345deque&lt;int&gt; dq {1, 2, 3};auto i = dq.begin();dq.push_front(4);dq.erase(i);cout &lt;&lt; dq.front() &lt;&lt; endl; 原理剖析当调用dq.erase(i)之后，程序发生了非法内存访问，debug过程中发现，当dq.push_front(4)之后，iterator就已经失效了，那么这是怎么发生的呢，首先我查询了deque在插入元素时的原理。 deque的空间由一段一段的定量连续空间构成，deque采用一块map作为主控，这个map是一块连续空间，其中每个元素都是指针，指向另一段较大的连续空间，称为缓冲区。 迭代器中需要四个指针，当前元素的指针，当前元素所在的缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓冲区的指针，迭代器的结构如下图所示。 接下来看STL中对于push_front()函数的具体实现 接下来我们通过一段代码来分析，push_front(4)之后发生了什么 12345678910111213141516171819202122232425cout &lt;&lt; dq.__capacity() &lt;&lt; endl;cout &lt;&lt; dq.__block_count() &lt;&lt; endl;dq.push_front(4);cout &lt;&lt; dq.__capacity() &lt;&lt; endl;cout &lt;&lt; dq.__block_count() &lt;&lt; endl;/*输出：1023120472*/auto i = dq.begin();auto j = dq.end() - 1;auto k = dq.end() - 3;cout &lt;&lt; &quot;4和3在内存中的距离&quot; &lt;&lt; (&amp;*i - &amp;*j) &lt;&lt; endl;cout &lt;&lt; &quot;3和1在内存中的距离&quot; &lt;&lt; (&amp;*j -&amp;*k) &lt;&lt; endl;/*输出：4和3在内存中的距离30693和1在内存中的距离2*/ 可以看出，在push_front(4)之后，deque直接又开辟了一片缓冲区，将4单独的放在了一个缓冲区上，而1，2，3则被放在了另一个缓冲区上。所以说之前指向1的迭代器因为缓冲区发生了变换，之前放置1的缓冲区已经失效，所以在此使用这个迭代器访问1就会出现内存访问错误。 vector类型的迭代器失效问题vector类型的容器在插入元素之后所需内存空间大于系统分配的内容空间空间的情况下，请求一块更大的连续内存空间，并将容器中已有的元素复制到新的内存空间中，那么在插入操作之前赋值的vector类型迭代器指向的内存空间就已经失效了。此时再用这个迭代器去访问和操作数据，就可能出现各种问题。 123456789101112vector&lt;int&gt; v1(10000, 0);auto iter1 = v1.begin();v1.push_back(1);v1.emplace(v1.begin(), 1);cout &lt;&lt; *iter1 &lt;&lt; endl;cout &lt;&lt; v1[0] &lt;&lt; endl;/*输出：01*/ 总结迭代器失效，本质上就是指针指向的内存空间上原本存在的数据已经发生了变化。这个事情提醒了我不要想当然的去对STL容器的底层做猜测假设，一定要对它的具体实现方法深入的了解。 参考资料 STL源码剖析——deque的实现原理和使用方法详解 std::deque::deque","link":"/2020/11/11/%E6%8E%A2%E7%A9%B6C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"},{"title":"梯度下降算法","text":"基本概念梯度下降法（Gradient descent）是一个一阶最优化算法，通常也称为最陡下降法，但是不该与近似积分的最陡下降法（Method of steepest descent）混淆。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。如果相反地向梯度正方向迭代进行搜索，则会接近函数的局部极大值点；这个过程则被称为梯度上升法。 梯度梯度是多元导数的概括。平常的一元（单变量）函数的导数是标量值函数，而多元函数的梯度是向量值函数。多元可微函数$f$在点$P$上的梯度，是以$f$在$P$上的偏导数为分量的向量。 散度散度（divergence）或称发散度，是向量分析中的一个向量算子，将向量空间上的一个向量场（矢量场）对应到一个标量场上。散度描述的是向量场里一个点是汇聚点还是发源点，形象地说，就是这包含这一点的一个微小体元中的向量是“向外”居多还是“向内”居多。 拉普拉斯算子在数学以及物理中，拉普拉斯算子或是拉普拉斯算符（Laplace operator, Laplacian）是由欧几里得空间中的一个函数的梯度的散度给出的微分算子. 参考资料 《深入浅出图神经网络》","link":"/2021/03/04/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"},{"title":"深入理解C++模版","text":"C++模版的形式函数模版针对参数类型不同的函数 类模版针对数据成员和成员函数不同的类 模板的形参类型形参、非类型形参和模板形参 类型形参类型形参由关见字class或typename后接说明符构成，可以定义多个类型形参。 模板形参（Template Template Parameters）就是将一个模板作为另一个模板的参数。一个template parameter本身也是一个class template。 无类型模版参数 模板的非类型形参也就是内置类型的形参，例如下列程序中int a就是非类型的模板形参 123template&lt;class T, int a&gt; class B { ...} 非类型模板的形参只能是整型，指针和引用 调用非类型模板形参的实参必须是一个常量表达式 全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参 参考资料 C++ 模板详解 C++ 函数模板&amp;类模板详解 C++模板","link":"/2020/11/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E6%A8%A1%E7%89%88/"},{"title":"OpenHarmony 开发环境搭建最佳实践","text":"概述目前OpenHarmony支持的L2设备主要是Hi3861、Hi3516、Hi3518这三种单板，三种设备的驱动目前都只支持Windows设备，所以如果代码开发涉及到烧写单板镜像就需要选择一个Windows开发设备。OpenHarmony的工具链包含repo、ninja、gn、pyhton，这些工具的配置在Linux开发设备上比较容易配置。如果在Windows设备上使用虚拟机，那么Linux系统只能通过软件指令集和硬件交互，效率比较低。所以比较好的实践是将开发环境部署在Linux服务器上，或者使用微软最近力推的WSL2。由于远程服务器的搭建方法在OpenHarmony官网上已经有比较详细的描述，本文将着力介绍如何使用WSL2搭建OpenHarmony开发环境。 WSL2安装WSL2的安装见微软官网。Linux发行版推荐使用Ubuntu20.04LTS，下文的介绍也将基于这个发行版进行。 OpenHarmony代码获取安装依赖1sudo apt-get update &amp;&amp; sudo apt-get install gnutls-bin gcc-arm-linux-gnueabi build-essential fakeroot dpkg-dev git-lfs build-essential gcc g++ make zlib* zip xsltproc x11proto-core-dev wget vim unzip u-boot-tools tzdata texinfo ssh scons python3-minimal python3-setuptools python3-pip python3-distutils python3-apt python3.8-distutils npm nfs-kernel-server mtools mtd-utils m4 locales libxml2-utils libx11-dev libreadline-dev libgl1-mesa-dev libffi* libc6-dev-x32 libc6-dev-i386 lib32z-dev lib32ncurses5-dev gperf gnupg git-lfs git-core g++-multilib g++ flex dosfstools default-jre default-jdk curl ccache build-essential bison binutils bc genext2fs ruby 安装工具1sudo curl -s https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &gt; /usr/local/bin/repo 创建代码目录拉取代码12345mkdir OpenHarmonycd OpenHarmonyrepo init -u https://gitee.com/openharmony/manifest.git -b OpenHarmony-3.0-LTS --no-repo-verifyrepo sync -crepo forall -c 'git lfs pull' 下载预编译工具1./build/prebuilts_download.sh IDE配置OpenHarmony的IDE配置与其他的远程开发配置无异，本文选取VSCode配置方法进行介绍。 插件安装使用微软官方开发的Remote-WSL插件能够让Windows本地的VSCode直接编辑WSL目录下的文件，并使用WSL环境下的开发环境使用IntelliSense进行语法错误的校验和智能代码补全。 编辑代码仓打开一个新的VSCode窗口 打开远端代码库在新窗口中，按F1呼出VSCode命令窗口，输入Remote-WSL,选择Remote-WSL：New WSL Window，此时会弹出一个新窗口，在其中按Ctrl + K Ctrl + O，此时会弹出一个打开Folder的选项。我们以OpenHarmony子系统ace_engine为例，输入子系统目录的绝对路径，点击回车，此时我们就打开了对应的子系统代码。 贡献代码注意，在本地创建Commits的时候，要在Commit信息中包含Signed-off-by信息。 我们在本地对OpenHarmony代码进行修改之后想要贡献到开源社区应该如何操作呢。作为开发者，一般不具备直接OpenHarmony代码仓提交代码的权限，一般都会采用fork &amp; pull request模型向OpenHarmony代码仓进行提交，接下来将以ace_engine子系统为例对具体的流程进行介绍。 Fork代码仓首先建立ace_engine的fork仓。 将修改推送到Fork代码仓 添加Fork代码仓的推送地址，git remote add fork $YOUR_FORK_ADDRESS 推送代码到Fork代码仓，git push fork HEAD:$YOUR_BRANCH 创建PR 签署OpenHarmoony DCO 创建PR并在PR中评论start build触发门禁构建 等待PR被committer合入 参考资料 Windows Subsystem for Linux Documentation OpenHarmony","link":"/2021/09/24/OpenHarmony-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"神经网络","slug":"神经网络","link":"/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"OpenHarmony","slug":"OpenHarmony","link":"/tags/OpenHarmony/"},{"name":"WSL2","slug":"WSL2","link":"/tags/WSL2/"}],"categories":[{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"区块链","slug":"区块链","link":"/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Lua","slug":"编程语言/Lua","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"图形学","slug":"图形学","link":"/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"C++","slug":"编程语言/C","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"图神经网络","slug":"图神经网络","link":"/categories/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"OpenHarmony","slug":"OpenHarmony","link":"/categories/OpenHarmony/"},{"name":"C#","slug":"编程语言/C","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}]}